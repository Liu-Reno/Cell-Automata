# 基于元胞自动机的小范围疫情防控模拟

## 理论部分

### 介绍

详情:

元胞自动机(Cell Automata)是一种处理复杂系统的良好办法.元胞自动机模型是空间,时间和状态均离散的动力系统,其演化过程依赖于细胞的状态以及细胞之间的相互作用,能够体现个体在空间和时间中的变化过程.元胞自动机模型相对于平均场模型,更趋近于现实.元胞自动机自诞生以来,已经被广泛地运用到了生物学,生态学,信息科学以及数学等领域.在研究动力系统的不平衡和空间不同质的系统中元胞自动机是一个强有力的工具.利用细胞自动机技术对传染病的传播规律以及控制研究也成为了传染病理论研究的重要方法.本文所研究的是含潜伏期,和康复期的SEAIR模型.

### 基本概念

一般而言,元胞自动机包括

1. 规则的离散格子($L$)和边界条件
2. 表征细胞的有限状态集合
3. 每个细胞的邻域($N^I$)
4. 决定细胞状态动力学演化规则($R$)

#### 格子

我们首先给出"细胞空间"(规则格子)的定义.规则的格子$L\subset \mathbb{R}^d$由一系列细胞组成,这些细胞可以覆盖$d$-维的$\text{Euclidean}$空间.每个细胞通过其位置$r\in L$进行标注.对于一个空间坐标$r\in L$而言,其邻居$N_b(r)$是一个由有限的邻居细胞所组成的集合
$$
N_b := \{r+c_i:c_i\in N_b(r)\}
$$
其中$b$是格子上最近的邻居数目.一维格子($d=1$)的格子由一组列细胞所组成,而每个细胞连接左右细胞$(b = 2)$,即$L\subset \Z$且$N_2 = \{1,-1\}$

本文所考虑的是二维的格子($d= 2$),其邻居被定义为
$$
N_b = \left\{c_i: c_i = \left(\cos \left(\frac{2\pi(i-1)}{b}\right),\sin\left(\frac{2\pi(i-1)}{b}\right)\right),i = 1,2,\cdots,b\right\}
$$
其中$b = 4$($N_4 = \{(1,0),(0,1),(-1,0),(0,-1)\}$)和$b = 6$的情况如下所示,其中深蓝色部分表示所考虑的细胞位置,浅蓝色部分表示其邻居细胞.

<img src="./../%E7%A4%BA%E6%84%8F%E5%9B%BE/%E5%85%83%E8%83%9E%E8%87%AA%E5%8A%A8%E6%9C%BA%E9%82%BB%E5%B1%85.png" alt="元胞自动机邻居" style="zoom:67%;" />

本文所考虑的情况便是$b = 4$的情况(容易在矩阵上表述).

在空间位置$i$的细胞被标记为$L_i$($i = 1,2,\cdots,d$),且细胞的总数目为$|L| = L_1\cdots L_d$.元胞自动机的格子数总是有限的,$|L| < \infty$.为了限制其格子数,本文采用的边界条件设置为:细胞永远无法逾越边界(具体编译内容见后文).

#### 邻域

记邻域$N_b^I(r)$为影响细胞$r$状态的格子的细胞集合.依据John von Neumann对于元胞自动机的定义,它的大小和拓扑结构并不依赖于格子细胞,并且不随着时间而改变.因此,邻域被定义为一个有序集合
$$
N_b^I(r) = \{r+c_i:c\in N_b^I\}
$$
边界上的邻域被定义为$N_b^I(r) \cup \text{Bd}(L)$,其中$\text{Bd}$为集合的边界.

比较著名的邻域有von Neumann邻域
$$
N_4^I = N_4 \cup \{(0,0)\}
$$
和Moore邻域(本文所采用的就是Moore邻域)
$$
N_4^I= \{(0,0),(0,1),(1,0),(1,1),(-1,0),(-1,1),(-1,-1),(0,-1),(1,-1)\}
$$
这两个邻域如下图所示

![两种邻域](./../%E7%A4%BA%E6%84%8F%E5%9B%BE/%E4%B8%A4%E7%A7%8D%E9%82%BB%E5%9F%9F.png)

#### 状态值

对于每一个细胞$r\in L$,我们都赋予其一个状态值$s(r) \in \mathfrak{S}$,即构建一个映射$s : L \to \mathfrak{S}$.将$\mathfrak{S}$称为状态空间,在本文中$\mathfrak{S}$由以下几个部分构成:

1. 细胞$r$上的易感者个数$S(r)$
2. 细胞$r$上的携带者个数$E(r)$
3. 细胞$r$上的感染者个数$I(r)$
4. 细胞$r$上的无症状感染者个数$A(r)$

所以$s$可以表示为
$$
\begin{align*}
s : L &\to \mathfrak{S}\\
r &\mapsto (S(r),E(r),I(r),A(r))
\end{align*}
$$
至于康复者我们只记录数量,若患者康复,则由于其不再对于元胞自动机内部产生任何影响,故可以将其删去.

#### 演化规则

首先,定义$\bullet \to *$为从状态$\bullet$转移成状态$*$这一事件.

对于元胞自动机的演化,会有不同的规则一起运行,而且这些规则的形式也并不唯一.本文中主要设置了三种规则

1. 转移规则(Transition rules):

   - 设传染率为$\beta$,若一个易感者$S$的Moore邻域内有$n$个感染者($I$)或无症状感染者($A$),则其被传染的概率为$P_T(S\to E) = \beta \times f(n)$,其中$f$为一个与$n$有关的函数.
   - 设转化率为$\alpha$,对于一个携带者$E$,其以$\alpha$的概率进行转化,即$P_T((E \to I)\cup (E\to A)) = \alpha$,并且$E\to I$与$E \to A$这两个事件的交集为空集$\varnothing$.因此$P_T((E\to I)\cup (E\to A)) = P_T(E \to A) +P_T(E \to A)$而且很明显$E \to I$和$E \to A$是对立事件,令$P_T(E\to A | (E\to I)\cup (E \to A)) = p$,则有$P_T(E \to I| (E \to I)\cup (E\to A)) = 1-p$,因此$P_T(E \to I) = \alpha(1-p)$,$P_T(E \to A) = \alpha p$ .
   - 令$P_T(A \to I)=\delta$,即每个无症状感染者有$\delta$的概率转化为感染者.
   - 设$P_T(I \to R)=r_I$和$P_T(A \to R)=r_A$.表示两者的康复率.

2. 移动规则(Movement rules):
   在施加移动移动规则$\mathcal{S}$前,细胞总是向着其邻域范围内的随机一点进行移动.在施加了移动限制条件$\mathcal{S}$后,细胞在遵守$\mathcal{S}$的基础上进行随机移动.

3. 同步或异步规则(Synchronous or Asynchronous rules)

   本文所采用的规则为异步规则,即细胞在运动时可以随机的选择一个位置.

#### 边界条件

定义(Boole矩阵):逻辑矩阵或Boole矩阵是由Boole域$B = \{0,1\}$所构成的矩阵.这样的矩阵表示一对有限集合之间的二元关系.

本文所采用的边界条件是一个区域的地图$Map$(此处假设地图为一个矩形),$Map$作为一个$n\times m$的Boole矩阵存在,选定有序对$(i,j)$,$i\in \{1,2,\cdots,n\},j\in \{1,2,\cdots,m\}$.其中,当$Map(i,j) = 1$时,表示细胞不能处于该格子,当$Map(i,j) = 0$时,表示细胞可以处于该格子.

在没有设置额外约束条件的前提下,移动规则$\mathcal{S}$规定如下
$$
\mathcal{S}(i,j) :=[Map((i,j)+t) = 0], \forall t\in \mathbb{T}
$$
其中$\mathbb{T}$为决策集,表示所有可能的移动方式所构成的集合,其内每一个元素$t$均为一个向量,$(i,j)+t$表示施行移动方式$t$后所处的位置.

移动规则示意图如下

![移动方式](./../%E7%A4%BA%E6%84%8F%E5%9B%BE/%E7%A7%BB%E5%8A%A8%E6%96%B9%E5%BC%8F.png)

图中灰色部分表示$Map(i,j) = 1$的部分,若细胞在第$n$步的移动方式$t_n \notin \mathcal{S}$,则$t_n = (0,0)$即细胞在第$n$步不进行移动.

### 本文中元胞自动机模型的逼近

为了方便元胞自动机结构研究以及参数的选择,本文将使用Chapman-Kolmogorov方程对于元胞自动机结构进行逼近,得到一个连续的传染病方程以进行参数拟合.

#### Chapman-Kolmogorov 方程

时间:2023.1.13

参与人员:刘欧,林锦,庄张育

指导老师:刘利利

详情:

由于任何一个确定性的元胞自动机模型均可以视为一个随机的模型.因此,只需要分析每个结构在每一步的概率分布,就可以研究整个演化过程.在时刻$k \in N_0$,令$\xi_k\in \mathfrak{S}$是随机过程$\{\xi_k\}_{k\in N_0}$的表达形式.给定任意一个初始状态分布$\xi_0 \in \mathfrak{S}$,对于$r_i \in M \subset L$,$m = |M|$,有
$$
P_k(s(r_1),\cdots,s(r_m)):=P(\xi_k(r_1) = s(r_1),\cdots,\xi_k (r_m) = s(r_m))
$$
用以描述在时刻$k$,结构$s_M \in \mathfrak{S}\mid_M$的概率.

在元胞自动机中,随机过程$\{\xi_k\}_{k\in N_0}$是一个Markov过程,也就是说其没有记忆性.这个过程是利用转移概率$P(\xi_{k+1} = s| \xi_k = \overline{s})$来表征,而这个转移概率描述的是时刻$k$状态为$\overline{s}$而时刻$k+1$状态为$s$的概率.局部细胞自动机规则是应用于每个格子同步的演化,且每个格子在下一步的状态为邻域的函数,即
$$
P(\xi_{k+1} = s | \xi_k = \overline{s}) = \prod_{r\in L}P(\xi_{k+1}(r)=s(r)|\xi_k\mid_{N_b^I(r)} = \overline{s}\mid_{N_b^I(r)})
$$
又由于局部规则是时间独立的,则对于$s,\overline{s}\in S$,$r_i \in N_b^I(r)$($i = 1,\cdots,v$),有
$$
\begin{align*}
P(\xi_{k+1} = s | \xi_k = \overline{s}) =& \prod_{r\in L}W(\overline{s}_{N(r)}\to s(r))\\
 = & W(\overline{s} \to s)
\end{align*}
$$
其中$W(s_A \to s_B)$表示,对于任意$A,B \subset L$,给定结构$s_A = s \mid_A$,达到结构$s_B = s \mid_B$时间独立的转移概率.随机过程$\{\xi_k\}_{k\in N_0}$是稳态Markov过程且其概率分布的时间演化可以用Chapman-Kolmogorov方程来表示
$$
P_{k+1}(s) = \sum_{\overline{s}\in \mathfrak{S}}P_k(\overline{s})W(\overline{s} \to s)=\sum_{\overline{s}\in \mathfrak{S}}P_k(\overline{s})\prod_{r\in L}W(\overline{s}_{N(r)} \to s(r))
$$

#### 实现

时间:2023.3.14

参与人员:刘欧,林锦,庄张育

指导老师:刘利利

详情:

首先给出本文的传染病方程所对应的仓室模型,用以得到各个$W$.

![传染病模型仓室图](./../%E7%A4%BA%E6%84%8F%E5%9B%BE/%E4%BC%A0%E6%9F%93%E7%97%85%E6%A8%A1%E5%9E%8B%E4%BB%93%E5%AE%A4%E5%9B%BE.png)

不难得到
$$
\begin{align}
W((s,e,a,i,r)\to(s-1,e+1,a,i,r)) =& \frac{\beta s(i+a)}{N}\\
W((s,e,a,i,r)\to(s,e-1,a+1,i,r)) =& \alpha p\\
W((s,e,a,i,r)\to(s,e-1,a,i+1,r)) =& \alpha(1-p)\\
W((s,e,a,i,r) \to (s,e,a-1,i+1,r)) = & \delta\\
W((s,e,a,i,r)\to (s,e,a-1,i,r+1)) =& r_A\\
W((s,e,a,i,r)\to (s,e,a,i-1,r+1)) =& r_I
\end{align}
$$
用$P(\sigma,t)$表示$t$时刻处于$\sigma$状态的概率,则有
$$
\dfrac{dP(\sigma,t)}{dt} = \sum_{\sigma'\neq \sigma}W(\sigma' \to \sigma)P(\sigma',t)-\sum_{\sigma \neq \sigma'}W(\sigma' \to \sigma)P(\sigma,t)
$$

令$S = \left<s\right> = \sum_{s,e,a,i,r = 0}^N sP(s,e,a,i,r;t)$,则有
$$
\begin{align*}
\dfrac{dS}{dt} = \dfrac{d\left<s\right>}{dt} =& - \sum_{s,e,a,i,r = 0}^N W((s,e,a,i,r)\to (s-1,e+1,a,i,r))P(s,e,a,i,r;t)\\
=& -\sum_{s,e,a,i,r = 0}^N \beta siP(s,e,a,i,r;t)
\end{align*}
$$
类似地,对于$E= \left<e\right>$,$A=\left<a\right>$,$I = \left<i\right>$和$R = \left<r\right>$有
$$
\begin{align*}
\dfrac{dE}{dt} =& \sum_{s,e,a,i,r = 0}^N W((s,e,a,i,r) \to (s-1,e+1,a,i,r))P(s,e,a,i,r;t)\\
-&\sum_{s,e,a,i,r = 0}^N(W((s,e,a,i,r)\to (s,e-1,a+1,i,r))\\
+& W((s,e,a,i,r)\to(s,e-1,a,i+1,r))P(s,e,a,i,r;t)),\\
\dfrac{dA}{dt} = & \sum_{s,e,a,i,r=0}^N W((s,e,a,i,r)\to (s,e-1,a+1,i,r))P(s,e,a,i,r;t)\\
-& \sum_{s,e,a,i,r = 0}^N (W((s,e,a,i,r)\to (s,e,a-1,i+1,r))\\
+& W((s,e,a,i,r)\to (s,e,a-1,i,r+1))P(s,e,a,i,r;t)),\\
\dfrac{dI}{dt} = & \sum_{s,e,a,i,r = 0}^N (W((s,e,a,i,r)\to (s,e-1,a,i+1,r))\\
+& W(s,e,a,i,r)\to (s,e,a-1,i+1,r))P(s,e,a,i,r;t)\\
-& \sum_{s,e,a,i,r=0}^N W((s,e,a,i,r)\to (s,e,a,i-1,r+1))P(s,e,a,i,r;t),\\
\dfrac{dR}{dt} =& \sum_{s,e,a,i,r =0 }^N (W((s,e,a,i,r)\to (s,e,a-1,i,r+1))\\
+& W((s,e,a,i,r) \to (s,e,a,i-1,r+1))P(s,e,a,i,r;t))
\end{align*}
$$
发现当$N \to \infty$时$\left<s,e,a,i,r\right> = \left<s\right>\left<e\right>\left<a\right>\left<i\right>\left<r\right>$,

令
$$
\overline{S} = \lim_{N\to \infty}\frac{S}{N}\\
\overline{E} = \lim_{N\to \infty}\frac{E}{N}\\
\overline{A} = \lim_{N\to \infty}\frac{A}{N}\\
\overline{I} = \lim_{N\to \infty}\frac{I}{N}\\
\overline{R} = \lim_{N\to \infty}\frac{R}{N}
$$

得到
$$
\begin{align*}
\dfrac{d\overline{S}}{dt} =& -\beta\overline{S}(\overline{I}+\overline{A})\\
\dfrac{d\overline{E}}{dt} =& \beta\overline{S}(\overline{I}+\overline{A})-\alpha \overline{E}\\
\dfrac{d\overline{A}}{dt} =& \alpha p \overline{E}-\delta \overline{A}-r_A\overline{A}\\
\dfrac{d\overline{I}}{dt} =& \delta\overline{A}+\alpha(1-p)\overline{E}-r_I\overline{I}\\
\dfrac{d\overline{R}}{dt} =& r_A\overline{A}+r_I\overline{I}
\end{align*}
$$
发现在不引起歧义的情况下我们可以使用$S$来代替$\overline{S}$,对于$E,A,I,R$也是如此.

可以由此进一步得到其对应的连续传染病方程.

## 实现

### 主函数(Main)

主函数分为三个部分:

第一部分:参数的导入以及初始化,其具体代码为

```matlab
parameter = readmatrix("参数.xlsx");
S0 = parameter(1);
E0 = parameter(2);
beta = parameter(3);
alpha = parameter(4);
p = parameter(5);
delta = parameter(6);
r_I = parameter(7);
r_A = parameter(8);
side = parameter(9);
map = readmatrix("map.xlsx");
[row,col] = find(map);
Position_of_map = [row,col];


[initial_S0,initial_E0] = initial(map,S0,E0);
%% 创建位置矩阵结构体
Position = struct( ...
    'susceptible_Matrix',zeros(1), ...
    'exposed_Matrix',zeros(1), ...
    'infectious_Matrix',zeros(1), ...
    'asymptomatic_Matrix',zeros(1));
%% 创建综合结构体
state = struct( ...%设置结构体
    'Position_of_susceptible',initial_S0 ,...
    'Position_of_exposed',initial_E0 ,...
    'Position_of_infectious',zeros(1,2), ...
    'Position_of_asymptomatic',zeros(1,2), ...
    'Position_of_recovered',zeros(1,2), ...
    'number_of_susceptible',S0 , ...
    'number_of_exposed',E0, ...
    'number_of_infectious',0, ...
    'number_of_recovered',0, ...
    'number_of_asymptomatic',0, ...
    'map',map, ...
    'Position',Position);
iteration= 500;%设置总迭代次数
```

第二部分:元胞自动机的迭代,其具体代码为

```matlab
for i = 1:iteration
    %% 设置更新函数
    state = NewPosition(map,state);%更新位置
    state = TransMatrix(state);%将位置转化为矩阵
    Plotstate(state,Position_of_map);%绘图
    axis([0,size(map,1),0,size(map,2)])%设置坐标系
    Position_of_susceptible(i)=getframe(gcf);%逐帧存放
    hold off
    state = Updatestate(state,beta,alpha,p,delta,r_I,r_A,side);%更新状态
end
```

第三部分:将每一次迭代的元胞自动机图片转化为一个视频,其具体代码为

```matlab
video_Position_of_Susceptible = VideoWriter('video_Position_of_Susceptible');
open(video_Position_of_Susceptible);
for k = 1:iteration
   writeVideo(video_Position_of_Susceptible,Position_of_susceptible(k));%Vedio写入
end
close(video_Position_of_Susceptible);
```

### 次级函数

#### 初始化函数 initial

初始化函数的具体代码为

```matlab
function [S,E] = initial(map,S0,E0)
n = S0+E0;%设置初始总人数
mapmartix = map;%导出地图
row = size(mapmartix,1);
list = size(mapmartix,2);
Position = zeros(n,2);
for i = 1:n% 给每个人的位置进行赋值
    stop = 0;% 设置停止判断
    while stop ==0 % 确保人不会出现在不该出现的位置
    p_list = randperm(list,1);
    p_row = randperm(row,1);
    if mapmartix(p_row,p_list) == 0% 确保人不会出现在限制区域
        stop = 1;
    end
    end
    Position(i,1) = p_list;
    Position(i,2) = p_row;
end
%% 对于位置进行赋值
S = Position(1:S0,1:2);
E = Position(S0+1:S0+E0,1:2);
end
```

#### 移动函数 NewPosition

该函数确定细胞的移动方式并且判断是否满足移动约束$\mathcal{S}$.其具体代码为

```matlab
function state = NewPosition(map,state)
%% 更新易感者位置
for i = 1:state.number_of_susceptible
    stop = 0;
    %% 设置移动步长行列均为-1到1
    while stop == 0
    list = randperm(3,1);
    list = list-2;
    row = randperm(3,1);
    row = row-2;

    if state.Position_of_susceptible(i,1)+row >0 && state.Position_of_susceptible(i,2)+list >0
    if abs(state.Position_of_susceptible(i,1)+row) <= size(map,1) && abs(state.Position_of_susceptible(i,2)+list) <= size(map,2) %% 判断是否超越边界
     if map(abs(state.Position_of_susceptible(i,1)+row),abs(state.Position_of_susceptible(i,2)+list)) == 0%判断是否会撞墙
        stop = 1;
     end
    end
    end
    end
        %% 更新位置
    state.Position_of_susceptible(i,1) = abs(state.Position_of_susceptible(i,1)+row);
    state.Position_of_susceptible(i,2) = abs(state.Position_of_susceptible(i,2)+list);
end
%% 更新携带者位置
for i = 1:state.number_of_exposed
        stop = 0;
    %% 设置移动步长行列均为-1到1
    while stop == 0
    list = randperm(3,1);
    list = list-2;
    row = randperm(3,1);
    row = row-2;
    if state.Position_of_exposed(i,1)+row >0 && state.Position_of_exposed(i,2)+list >0
    if abs(state.Position_of_exposed(i,1)+row) <= size(map,1) && abs(state.Position_of_exposed(i,2)+list) <= size(map,2) %% 判断是否超越边界
    if map(abs(state.Position_of_exposed(i,1)+row),abs(state.Position_of_exposed(i,2)+list)) == 0%判断是否会撞墙
        stop = 1;
    end
    end
    end
    end
        %% 更新位置
    state.Position_of_exposed(i,1) = abs(state.Position_of_exposed(i,1)+row);
    state.Position_of_exposed(i,2) = abs(state.Position_of_exposed(i,2)+list);
end
%% 更新染病者位置
if state.number_of_infectious ~= 0
    for i = 1:state.number_of_infectious
        stop = 0;
    %% 设置移动步长行列均为-1到1
    while stop == 0
    list = randperm(3,1);
    list = list-2;
    row = randperm(3,1);
    row = row-2;
    %% 判断是否越界
    if state.Position_of_infectious(i,1)+row >0 && state.Position_of_infectious(i,2)+list >0
    if abs(state.Position_of_infectious(i,1)+row) <= size(map,1) && abs(state.Position_of_infectious(i,2)+list) <= size(map,2) %% 判断是否超越边界
    if map(abs(state.Position_of_infectious(i,1)+row),abs(state.Position_of_infectious(i,2)+list)) == 0%判断是否会撞墙
        stop = 1;
    end
    end
    end
    end
        %% 更新位置
    state.Position_of_infectious(i,1) = abs(state.Position_of_infectious(i,1)+row);
    state.Position_of_infectious(i,2) = abs(state.Position_of_infectious(i,2)+list);
    end
end
%% 更新无症状感染者位置
if state.number_of_asymptomatic ~= 0
    for i = 1:state.number_of_asymptomatic
        stop = 0;
    %% 设置移动步长行列均为-1到1
    while stop == 0
    list = randperm(3,1);
    list = list-2;
    row = randperm(3,1);
    row = row-2;
    if state.Position_of_asymptomatic(i,1)+row >0 && state.Position_of_asymptomatic(i,2)+list >0
    if abs(state.Position_of_infectious(i,1)+row) <= size(map,1) && abs(state.Position_of_infectious(i,2)+list) <= size(map,2) %% 判断是否超越边界
    if map(abs(state.Position_of_infectious(i,1)+row),abs(state.Position_of_infectious(i,2)+list)) == 0%判断是否会撞墙
        stop = 1;
    end
    end
    end
    end
        %% 更新位置
    state.Position_of_asymptomatic(i,1) = abs(state.Position_of_asymptomatic(i,1)+row);
    state.Position_of_asymptomatic(i,2) = abs(state.Position_of_asymptomatic(i,2)+list);
    end
end
```



#### 位置转化为矩阵函数 TransMatrix

该函数的目的是为状态转移方程寻找邻域做准备,其具体代码为

```matlab
function state = TransMatrix(state)

%% 开始构建位置矩阵
map= zeros(size(state.map,1),size(state.map,2));%制造一个空地图
state.Position.susceptible_Matrix = map;
state.Position.exposed_Matrix = map;
state.Position.infectious_Matrix = map;
state.Position.asymptomatic_Matrix = map;
for i = 1:state.number_of_susceptible
    state.Position.susceptible_Matrix(state.Position_of_susceptible(i,1),state.Position_of_susceptible(i,2)) = 1;%将有人所在的位置赋值为1
end
for i = 1:state.number_of_exposed
    state.Position.exposed_Matrix(state.Position_of_exposed(i,1),state.Position_of_exposed(i,2)) = 1;
end
for i = 1:state.number_of_infectious
    state.Position.infectious_Matrix(state.Position_of_infectious(i,1),state.Position_of_infectious(i,2)) = 1;
end
for i = 1:state.number_of_asymptomatic
    state.Position.asymtomatic_Matrix(state.Position_of_asymptomatic(i,1),state.Position_of_asymptomatic(i,2)) = 1;
end
end
```

#### 状态更新函数(状态转移函数) Updatestate

该函数表示转移规则,其具体代码为

```matlab
function state = Updatestate(state,beta,alpha,p,delta,r_I,r_A,side)

%% 初始化
    judge_susceptible = zeros(state.number_of_susceptible,1);
    judge_exposed = zeros(state.number_of_exposed,1);
    judge_infectious = zeros(state.number_of_infectious,1);
    judge_asymptomatic = zeros(state.number_of_asymptomatic,1);
    %% 计算第i个易感者的邻域范围内有多少个感染者
for i =1:state.number_of_susceptible
    number_of_infectious = zeros(2*side);
    for j = -side:side
        for k = -side:side
            %% 防止超界(防止撞墙已经于NewPosition.m)中设计
            if state.Position_of_susceptible(i,1)+j <=0 || state.Position_of_susceptible(i,1)+j >=size(state.map,1)
                j_1 = 0;
            else
                j_1 = j;
            end
            if state.Position_of_susceptible(i,2)+k <=0 || state.Position_of_susceptible(i,2)+k >=size(state.map,2)
                k_1 = 0;
            else
                k_1 = k;
            end

            number_of_infectious(j+side+1,k+side+1) = sum(state.Position.infectious_Matrix(state.Position_of_susceptible(i,1)+j_1,state.Position_of_susceptible(i,2)+k_1))+ ...计算邻域范围内的感染者个数 
            sum(state.Position.asymptomatic_Matrix(state.Position_of_susceptible(i,1)+j_1,state.Position_of_susceptible(i,2)+k_1));%计算邻域范围内的无症状感染者个数
        end
    end
    %% 进行求和(分两步求和,方便报错检查)
number_of_infectious_1 = sum(number_of_infectious);
number_of_infectious_2 = sum(number_of_infectious_1);
    %% 判断是否被感染
    if rand <= f(number_of_infectious_2,beta)
        judge_susceptible(i) = 1;% 若judge_exposed(i) = 1则表示此时第i个易感者被感染,若为0则未被感染
    else 
        judge_susceptible(i) = 0;
    end
end
%% 携带者转化判定
for i=1:state.number_of_exposed
    if rand <= alpha%确诊
        if rand <= p
        judge_exposed(i) = 1;%转化为感染者
        else 
        judge_exposed(i) = 2;%转化为无症状感染者
        end
    else
        judge_exposed(i) = 0;%保持不变
    end
end
%% 感染者转化判定
if state.number_of_infectious >0
    for i = 1:state.number_of_infectious
        if rand <= r_I
            judge_infectious(i) = 1;%康复
        else
            judge_infectious(i) = 0;%保持不变
        end
    end
end
%% 无症状感染者转化判定
if state.number_of_asymptomatic >0
    for i = 1:state.number_of_asymptomatic
        if rand >= r_A
            if rand <= delta
                judge_asymptomatic(i) = 2;%转化为感染者
            else
                judge_asymptomatic(i) = 0;%保持不变
            end
        else 
            judge_asymptomatic(i) = 1;%转化为康复者
        end
    end
end
%% 总结
J_S_1 = find(judge_susceptible == 1);% S \to E
J_E_1 = find(judge_exposed == 1);% E \to I
J_E_2 = find(judge_exposed == 2);% E \to A
J_A_1 = find(judge_asymptomatic == 1);% A \to R
J_A_2 = find(judge_asymptomatic == 2);% A \to I
J_I_1 = find(judge_infectious == 1);% I \to R

%% Update阶段

%% 更新S
state.number_of_susceptible = state.number_of_susceptible - length(J_S_1);%更新易感者人数
S_to_E = zeros(length(J_S_1),2);
for i = 1: length(J_S_1)
    S_to_E(i,:) = state.Position_of_susceptible(J_S_1(i),:);
end
state.Position_of_susceptible(J_S_1,:) = [];%在易感者中删去携带者

%% 更新E
E_to_I = zeros(length(J_E_1),2);
E_to_A = zeros(length(J_E_2),2);
for i = 1:length(J_E_1)
    E_to_I(i,:) = state.Position_of_exposed(J_E_1(i),:);
end
for i = 1:length(J_E_2)
    E_to_A(i,:) = state.Position_of_exposed(J_E_2(i),:);
end
J_E = union(J_E_1,J_E_2);
state.number_of_exposed = state.number_of_exposed - length(J_E) + size(S_to_E,1);%更新携带者人数
state.Position_of_exposed(J_E,:) = [];%在携带者中删除流出部分
State_P_E = size(state.Position_of_exposed,1);
for i = size(state.Position_of_exposed,1)+1:state.number_of_exposed
    state.Position_of_exposed(i,:) = S_to_E(i - State_P_E,:);% 更新携带者位置
end


%% 更新A
if state.number_of_asymptomatic >0
A_to_R = zeros(length(J_A_1),2);
A_to_I = zeros(length(J_A_2),2);
for i = 1:length(J_A_1)
    A_to_R(i,:) = state.Position_of_asymptomatic(J_A_1(i),:);
end
for i = 1:length(J_A_2)
    A_to_I(i,:) = state.Position_of_asymptomatic(J_A_2(i),:);
end
J_A = union(J_A_1,J_A_2);
state.number_of_asymptomatic = state.number_of_asymptomatic - length(J_A) + size(E_to_A,1);%更新无症状感染者人数
state.Position_of_asymptomatic(J_A,:) = [];%在无症状感染者中删去流出部分
State_P_A = size(state.Position_of_asymptomatic,1);
for i = size(state.Position_of_asymptomatic,1)+1:state.number_of_asymptomatic
    state.Position_of_asymptomatic(i,:) = E_to_A(i- State_P_A,:);% 更新无症状感染者位置
end
else
    for i = 1:size(E_to_A,1)
    state.Position_of_asymptomatic(i,:) = E_to_A(i,:);% 更新无症状感染者位置
    end
    state.number_of_asymptomatic = length(J_E_2);
    A_to_I = [];
    A_to_R = [];
end


%% 更新I
if state.number_of_infectious >0
  state.number_of_infectious = state.number_of_infectious - length(J_I_1) + size(A_to_I,1) + size(E_to_I,1);
  state.Position_of_infectious(J_I_1,:) = [];
  State_P_I = size(state.Position_of_infectious,1);
  for i = size(state.Position_of_infectious,1)+1:state.number_of_infectious - size(A_to_I,1)
    state.Position_of_infectious(i,:) = E_to_I(i-State_P_I,:);
  end
  State_P_I = size(state.Position_of_infectious,1);
  for i = size(state.Position_of_infectious,1)+1 : state.number_of_infectious
    state.Position_of_infectious(i,:) = A_to_I(i-State_P_I,:);
  end
else
    state.number_of_infectious = state.number_of_infectious +  size(A_to_I,1) + size(E_to_I,1);
    if state.number_of_infectious - size(A_to_I,1) >= 1
      for i = 1: state.number_of_infectious - size(A_to_I,1)
      state.Position_of_infectious(i,:) = E_to_I(i,:);
      end
    end

        State_P_I = size(state.Position_of_infectious,1);
     if state.number_of_infectious >1
  for i = size(state.Position_of_infectious,1)+1 : state.number_of_infectious
    state.Position_of_infectious(i,:) = A_to_I(i-State_P_I,:);
  end
     end
end

%% 更新R
state.number_of_recovered = state.number_of_recovered+ size(A_to_R,1) +length(J_I_1);
end
```

其中$f(N(I),\beta)$为感染率函数,可以进行修改,其具体代码为

```matlab
%% 设置感染率叠加函数
function a = f(number_of_infectious,beta)
if number_of_infectious*beta <= 0.9
    a = number_of_infectious;
else
    a = 0.9;
end
end
```

#### 绘图函数 Plotstate

这个函数将状态绘制为散点图,其具体代码为

```matlab
function Plotstate(state,Position_of_map)
        %% 易感者
        scatter(state.Position_of_susceptible(:,1),state.Position_of_susceptible(:,2),15,[126/256,211/256,33/256],"filled");
        hold on
        %% 携带者
        scatter(state.Position_of_exposed(:,1),state.Position_of_exposed(:,2),15,[248/256,231/256,28/256],"filled");
        hold on
        %% 感染者
        if state.number_of_infectious > 0
            scatter(state.Position_of_infectious(:,1),state.Position_of_infectious(:,2),15,[245/256,166/256,35/256],"filled");
            hold on
        end
        %% 无症状感染者
        if state.number_of_asymptomatic > 0
            scatter(state.Position_of_asymptomatic(:,1),state.Position_of_asymptomatic(:,2),15,[208/256,2/256,27/256],"filled");
            hold on
        end
        %% 绘制边界
        scatter(Position_of_map(:,1),Position_of_map(:,2),[],[155/156,155/256,155/256],"square","filled");
end
```

## 额外优化(创新点)

### 移动规则更新

#### 介绍

一个只会随机移动的细胞和具有固定趋向进行移动的细胞对于元胞自动机演示结果的影响是截然不同的,因此我们对于移动限制$\mathcal{S}$作出优化,增加了几个对于细胞具有吸引力的点,我们将其称为"引力点"$P_0$.在引力点周围的点会收到其吸引力,从而向其靠拢.

#### 实现方式

假设细胞的位置处于$r\in L$.细胞将会按照下图进行速度更新.

<img src="./../%E7%A4%BA%E6%84%8F%E5%9B%BE/%E9%80%9F%E5%BA%A6%E6%9B%B4%E6%96%B0%E6%96%B9%E5%BC%8F.png" alt="速度更新方式" style="zoom:50%;" />

对于原速度$\vec{r}_0$,根据引力点$P_0$施加速度修正$\vec{\mathcal{R}}:= \overrightarrow{P_0r}$,接着利用参考粒子群算法速度更新公式所得到的细胞速度更新公式求得速度$\vec{v}$为
$$
\vec{v}w\times \vec{r}_0 +\text{rand}\times \vec{\mathcal{R}}
$$
其中,$w$为惯性权重,$\text{rand}$为一个$[0,1]$间的随机值.

而后,对于$\vec{v}$的各个分量$v_i$向下取整,得到$[\vec{v}]$为最终所采用的速度.但是,由于$v_i$不一定属于$[0,2]$,因此我们需要设置一个系数$k$使得细胞可以正常移动.

#### 代码(以$S$为例)

```matlab
    while stop == 0
    list = randperm(3,1);
    list = list-2;
    row = randperm(3,1);
    row = row-2;
    r = [list,row];
    P1 = P_0 - state.Position_of_susceptible(i)+[rand,rand];
    P = rand*P1/norm(P1)+weight(state)*r;
    P = round(1.5*P);
    if state.Position_of_susceptible(i,1)+P(1) >0 && state.Position_of_susceptible(i,2)+P(2) >0
    if abs(state.Position_of_susceptible(i,1)+P(1)) < size(map,1) && abs(state.Position_of_susceptible(i,2)+P(2)) < size(map,2) %% 判断是否超越边界
     if map(abs(state.Position_of_susceptible(i,1)+P(1)),abs(state.Position_of_susceptible(i,2)+P(2))) == 0%判断是否会撞墙
        stop = 1;
     end
    end
    end
```

#### 下一步设想

##### 引力点设置为一个时变函数

接下来,打算对于$P_0$进行改动,不再将$P_0$设置为一个固定的点,而是给$P_0$设置某个轨迹进行移动,从而模拟上下课,吃饭以及其它活动.

<img src="./../%E7%A4%BA%E6%84%8F%E5%9B%BE/%E5%BC%95%E5%8A%9B%E7%82%B9%E8%BD%AC%E7%A7%BB%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="引力点转移示意图" style="zoom:50%;" />

##### 引力点追随判断

让细胞追寻障碍物阻隔最小的引力点.

### 人员流动规则

设置学校的出入口$G$,当细胞移动到出入口$G$时,细胞会消失.同时在每次迭代中,以$p$的概率在出入口生成细胞,而后对于细胞状态进行判断,以$p_i$的概率生成第$i$类人群.

下图为出校示意图

<img src="./../%E7%A4%BA%E6%84%8F%E5%9B%BE/%E4%BA%BA%E5%91%98%E6%B5%81%E5%8A%A8.png" alt="人员流动" style="zoom:50%;" />

下图为入校示意图,图例与上图保持一致

<img src="./../%E7%A4%BA%E6%84%8F%E5%9B%BE/%E5%85%A5%E6%A0%A1.png" alt="入校" style="zoom:50%;" />

### 疫苗接种者

增加疫苗接种者$V$的存在.疫苗接种者被传染的概率降低,即将映射$f(N(I),\beta)$变为映射$f(N(I),\beta,V)$.

### 对于细胞赋予"个体意志"

#### 设想

对于疫情的防控不仅仅需要考虑宏观政策,同时还需要综合考虑个人的道德水平,防疫执行情况等内容,每个细胞都可以自行决定是否执行某项防疫措施以及下一步该如何去行动.因此本文将其作为粒子群算法的编码进行实现.

#### 观察

观察到细胞移动的决策集$\mathbb{T}$只有$9$个元素,即$|T| = 9$.因此可以得到以下编码

| 编码                 | 0       | 1        | 2       | 3       | 4        | 5       | 6         | 7        | 8        |
| -------------------- | ------- | -------- | ------- | ------- | -------- | ------- | --------- | -------- | -------- |
| **行动**(对应于向量) | $(0,0)$ | $(1,-1)$ | $(1,0)$ | $(1,1)$ | $(0,-1)$ | $(0,1)$ | $(-1,-1)$ | $(-1,0)$ | $(-1,1)$ |

因此,我们只需要设计$N$个粒子,对于每个粒子设置如上所示的规则,就可以决定所有细胞的移动方式.

#### 细胞的速度更新公式

假设细胞在当前迭代中的决策为$t$,且$t\in \mathcal{S}$,则在考虑引力点$P_0$所带来的速度修正$\vec{\mathcal{R}}$的前提下.细胞的速度更新公式应当为
$$
\vec{v} = w\times t + \text{rand}\times \vec{\mathcal{R}}
$$
其中各个变量均与引力点情况下的速度更新公式保持一致.

#### 损失函数设计

损失函数的设计主要参考两个指标:个体自由度$free$(与防疫力度呈反比)以及恐慌度$Panic$(即邻域范围内的感染者个数).

损失函数$\text{Loss}: = \sum_{i = 1}^N(w_1 \times free + w_2 \times Panic)$. 

## 结果演示

### 参数设置

此次结果演示为无引力点版本的结果演示,其中参数设置为

| 符号     | 描述                         | 取值  |
| -------- | ---------------------------- | ----- |
| $\beta$  | 传染率                       | 0.4   |
| $\alpha$ | 转化率                       | 0.1   |
| $p$      | 转移至无症状感染者概率       | 0.4   |
| $\delta$ | 无症状感染者转移至感染者概率 | 0.15  |
| $r_A$    | 无症状感染者康复率           | 0     |
| $r_I$    | 感染者康复率                 | 0     |
| $S_0$    | 易感者初值                   | 12000 |
| $E_0$    | 携带者初值                   | 10    |
|          |                              |       |
### 结果演示

#### 数值变化

元胞自动机的演示结果如下图所示,其中左侧为$S$的变化情况,右侧为$A+I$的变化情况

<center><img src="./../%E7%A4%BA%E6%84%8F%E5%9B%BE/S.jpg" alt="S" style="zoom: 25%;" /><img src="./../%E7%A4%BA%E6%84%8F%E5%9B%BE/A+I.jpg" alt="A+I" style="zoom:25%;" /></center>

 <center>左图为S的变化情况,右图为A+I的变化情况</center>        

#### 实时结果

<center><img src="./../%E7%A4%BA%E6%84%8F%E5%9B%BE/Picture1.jpg" alt="Picture1" style="zoom:15%;" /><img src="./../%E7%A4%BA%E6%84%8F%E5%9B%BE/Picture80.jpg" alt="Picture1" style="zoom:15%;" ></center>

<center>   左图为第0次迭代时的分布,右图为第80次迭代时的分布 
<center>
    <img src="./../%E7%A4%BA%E6%84%8F%E5%9B%BE/Picture160.jpg" alt="Picture160" style="zoom:15%;" /><img src="./../%E7%A4%BA%E6%84%8F%E5%9B%BE/Picture240.jpg" alt="Picture240" style="zoom:15%;" />
</center>

<center>
    左图为第160次迭代时的分布,右图为第240次迭代时的分布
</center>
<center>
    <img src="./../%E7%A4%BA%E6%84%8F%E5%9B%BE/Picture320.jpg" alt="Picture320" style="zoom:15%;" />
    <img src="./../%E7%A4%BA%E6%84%8F%E5%9B%BE/Picture400.jpg" alt="Picture400" style="zoom:15%;" />
</center>

<center>
    左图第320次迭代时的分布,右图为第400次迭代时的分布
</center>
<center>
    <img src="./../%E7%A4%BA%E6%84%8F%E5%9B%BE/Picture500.jpg" alt="Picture500" style="zoom:15%;" /><img src="./../%E7%A4%BA%E6%84%8F%E5%9B%BE/Picture600.jpg" alt="Picture600" style="zoom:15%;" />
</center>

<center>
    左图为第500次迭代时的分布,右图为第600次迭代时的分布
</center>
# 后半段

## 隔离操作

利用前文提到的引力点原理，将染病者进行隔离（隔离到引力点处）引力点设置在墙内，保证隔离后的感染者无法对于外界进行传播。

## 加入隔离措施的ode方程

现在，我们进行一次更新，将隔离这一控制措施引入传染病模型中，而后进行研究。

此时，$I$被划分为两个部分($\hat{I}$与$\tilde{I}$)，其中$\hat{I}$代表未被隔离的人，$\tilde{I}$代表已经被隔离的人。我们通过一个转化率$\text{R}_{iso}$来探究这种关系。为了方便起见，我们约定所有隔离者都将在$1/\text{R}_{iso}$时赶到隔离点，或者说$1/\text{R}_{iso}$为隔离者赶到隔离点的平均用时，则我们可以对于元胞自动机的传播关系进行一次优化。
$$
\begin{align*}
W((s,e,a,\hat{i},\tilde{i},r)&\to(s-1,e+1,a,\hat{i},\tilde{i},r)) = \frac{\beta s(\hat{i}+\sigma a)}{N}\\
W((s,e,a,\hat{i},\tilde{i},r)&\to(s,e-1,a+1,\hat{i},\tilde{i},r)) = \alpha p\\
W((s,e,a,\hat{i},\tilde{i},r)&\to(s,e-1,a,\hat{i}+1,\tilde{i},r)) = \alpha(1-p)\\
W((s,e,a,\hat{i},\tilde{i},r) &\to (s,e,a-1,\hat{i}+1,\tilde{i},r)) =  \delta\\
W((s,e,a,\hat{i},\tilde{i},r) &\to (s,e,a,\hat{i}-1,\tilde{i}+1,r)) =  \text{R}_{iso}\\
W((s,e,a,\hat{i},\tilde{i},r)&\to (s,e,a-1,\hat{i},\tilde{i},r+1)) = r_A\\
W((s,e,a,\hat{i},\tilde{i},r)&\to (s,e,a,\hat{i},\tilde{i}-1,r+1)) = r_I 
\end{align*}
$$
用$P(\sigma,t)$表示$t$时刻处于$\sigma$状态的概率,则有
$$
\dfrac{dP(\sigma,t)}{dt} = \sum_{\sigma'\neq \sigma}W(\sigma' \to \sigma)P(\sigma',t)-\sum_{\sigma \neq \sigma'}W(\sigma' \to \sigma)P(\sigma,t)
$$
令$S = \left<s\right> = \sum_{s,e,a,\hat{i},\tilde{i},r = 0}^N sP(s,e,a,\hat{i},\tilde{i},r;t)$,则有
$$
\begin{align*}
\dfrac{dS}{dt} = \dfrac{d\left<s\right>}{dt} =& - \sum_{s,e,a,\hat{i},\tilde{i},r = 0}^N W((s,e,a,\hat{i},\tilde{i},r)\to (s-1,e+1,a,\hat{i},\tilde{i},r))P(s,e,a,\hat{i},\tilde{i},r;t)\\
=& -\sum_{s,e,a,\hat{i},r = 0}^N \beta siP(s,e,a,\hat{i},\tilde{i},r;t)
\end{align*}
$$
类似地,对于$E= \left<e\right>$,$A=\left<a\right>$,$I = \left<i\right>$和$R = \left<r\right>$有
$$
\begin{align*}
\dfrac{dE}{dt} =& \sum_{s,e,a,\hat{i},\tilde{i},r = 0}^N W((s,e,a,\hat{i},\tilde{i},r) \to (s-1,e+1,a,\hat{i},\tilde{i},r))P(s,e,a,\hat{i},\tilde{i},r;t)\\
-&\sum_{s,e,a,\hat{i},\tilde{i},r = 0}^N(W((s,e,a,\hat{i},\tilde{i},r)\to (s,e-1,a+1,\hat{i},\tilde{i},r))\\
+& W((s,e,a,\hat{i},\tilde{i},r)\to(s,e-1,a,\hat{i}+1,\tilde{i},r))P(s,e,a,\hat{i},\tilde{i},r;t)),\\
\dfrac{dA}{dt} = & \sum_{s,e,a,\hat{i},\tilde{i},r=0}^N W((s,e,a,\hat{i},\tilde{i},r)\to (s,e-1,a+1,\hat{i},\tilde{i},r))P(s,e,a,\hat{i},\tilde{i},r;t)\\
-& \sum_{s,e,a,\hat{i},\tilde{i},r = 0}^N (W((s,e,a,\hat{i},\tilde{i},r)\to (s,e,a-1,\hat{i}+1,\tilde{i},r))\\
+& W((s,e,a,\hat{i},\tilde{i},r)\to (s,e,a-1,\hat{i},\tilde{i},r+1))P(s,e,a,\hat{i},\tilde{i},r;t)),\\
\dfrac{d\hat{I}}{dt} = & \sum_{s,e,a,\hat{i},\tilde{i},r = 0}^N (W((s,e,a,\hat{i},\tilde{i},r)\to (s,e-1,a,\hat{i}+1,\tilde{i},r))\\
+& W(s,e,a,\hat{i},\tilde{i},r)\to (s,e,a-1,\hat{i}+1,\tilde{i},r))P(s,e,a,i,r;t)\\
-& \sum_{s,e,a,\hat{i},\tilde{i},r=0}^N W((s,e,a,\hat{i},\tilde{i},r)\to (s,e,a,\hat{i},\tilde{i}-1,r+1))P(s,e,a,\hat{i},\tilde{i},r;t),\\
\dfrac{dR}{dt} =& \sum_{s,e,a,\hat{i},\tilde{i},r =0 }^N (W((s,e,a,\hat{i},\tilde{i},r)\to (s,e,a-1,\hat{i},\tilde{i},r+1))\\
+& W((s,e,a,\hat{i},\tilde{i},r) \to (s,e,a,\hat{i},\tilde{i}-1,r+1))P(s,e,a,\hat{i},\tilde{i},r;t))
\end{align*}
$$
发现当$N \to \infty$时$\left<s,e,a,\hat{i},\tilde{i},r\right> = \left<s\right>\left<e\right>\left<a\right>\hat{\left<{i}\right>}\tilde{\left<i\right>}\left<r\right>$,

令
$$
\underline{S} = \lim_{N\to \infty}\frac{S}{N}\\
\underline{E} = \lim_{N\to \infty}\frac{E}{N}\\
\underline{A} = \lim_{N\to \infty}\frac{A}{N}\\
\underline{\hat{I}} = \lim_{N\to \infty}\frac{\hat{I}}{N}\\
\underline{\tilde{I}} = \lim_{N\to \infty}\frac{\tilde{I}}{N}\\
\underline{R} = \lim_{N\to \infty}\frac{R}{N}
$$
得到
$$
\begin{align*}
\dfrac{d\underline{S}}{dt} =& -\beta\underline{S}(\underline{\hat{I}}+\underline{A})\\
\dfrac{d\underline{E}}{dt} =& \beta\underline{S}(\underline{I}+\underline{A})-\alpha \underline{E}\\
\dfrac{d\underline{A}}{dt} =& \alpha p \underline{E}-\delta \underline{A}-r_A\underline{A}\\
\dfrac{d\underline{\hat{I}}}{dt} =& \delta\underline{A}+\alpha(1-p)\underline{E}-\text{R}_{iso}\underline{I}\\
\dfrac{d\underline{\tilde{I}}}{dt} =& \text{R}_{iso}\underline{I}-r_I \underline{\tilde{I}} \\
\dfrac{d\underline{R}}{dt} =& r_A\underline{A}+r_I\underline{\tilde{I}}
\end{align*}
$$

## 新的地图

对于地图进行了一些改进，

<img src="./../%E7%A4%BA%E6%84%8F%E5%9B%BE/%E6%96%B0%E7%9A%84%E5%9C%B0%E5%9B%BE.png" alt="新的地图" style="zoom:50%;" />

[更新说明]：增加了部分建筑，使得地图更加合理，增加隔离区。

## 新的代码

改动：增加隔离，现在康复者将会显示在地图上，而不是如先前一般隐去。

### 新的主函数

```matlab
%%%%%%%%%%%%%%%%%%%%%%%
% 本程序为带边界的元胞自动机程序
% Author: Liu Ou
%%%%%%%%%%%%%%%%%%%%%%%

clear
clc
parameter = readmatrix("参数.xlsx");
S0 = parameter(1);
E0 = parameter(2);
beta = parameter(3);
alpha = parameter(4);
p = parameter(5);
delta = parameter(6);
r_I = parameter(7);
r_A = parameter(8);
side = parameter(9);
map = zeros(500);
[row,col] = find(map);
Position_of_map = [row,col];
iteration= 2400;%设置总迭代次数
[initial_S0,initial_E0] = initial(map,S0,E0);
%% 创建位置矩阵结构体
Position = struct( ...
    'susceptible_Matrix',zeros(1), ...
    'exposed_Matrix',zeros(1), ...
    'infectious_Matrix',zeros(1), ...
    'asymptomatic_Matrix',zeros(1), ...
    'recover_Matrix',zeros(1));
%% 创建综合结构体
state = struct( ...%设置结构体
    'Position_of_susceptible',initial_S0 ,...
    'Position_of_exposed',initial_E0 ,...
    'Position_of_infectious',zeros(1,2), ...
    'Position_of_asymptomatic',zeros(1,2), ...
    'Position_of_recovered',zeros(1,2), ...
    'number_of_susceptible',S0 , ...
    'number_of_exposed',E0, ...
    'number_of_infectious',0, ...
    'number_of_recovered',0, ...
    'number_of_asymptomatic',0, ...
    'map',map, ...
    'Position',Position, ...
    'Iteration',0, ...
    'Max_Iteration',iteration, ...
    'point',true,...
    'point_Position',[64,28]);
%% 准备迭代
data_folder = './Fig_fit/'; %生成sijv_vaccination名字的文件夹
if ~isfolder(data_folder)  %低版本Matlab，使用isidr()函数；高版本Matlab，使用isfolder()函数
    mkdir(data_folder);
end
for i = 1:iteration
    state.Iteration = i;% 更新当前迭代次数
    %% 设置更新函数
    state = NewPosition(map,state);%更新位置
    state = TransMatrix(state);%将位置转化为矩阵
    Plotstate(state,Position_of_map);%绘图
    axis([0,size(map,1),0,size(map,2)])%设置坐标系
    Position_of_susceptible(i)=getframe(gcf);%逐帧存放  
    if i == 1 || 40 || 80 || 120 || 160 || 200 || 300 || 400 || 800
        A = char("Picture"+num2str(i));
        filename = [data_folder,A ]; %图形保存在data_folder文件夹中
       print(gcf, filename, '-djpeg', '-r300');
    end
    hold off
    state = Updatestate(state,beta,alpha,p,delta,r_I,r_A,side);%更新状态
     %% 记录人数
        S(i) = state.number_of_susceptible;
        A(i) = state.number_of_asymptomatic;
        I(i) = state.number_of_infectious;
        R(i) = state.number_of_recovered;
end
figure
plot(S);
figure
plot(A+I);
figure
plot(R);
video_Position_of_Susceptible = VideoWriter('video_Position_of_Susceptible');
open(video_Position_of_Susceptible);
for k = 1:iteration
   writeVideo(video_Position_of_Susceptible,Position_of_susceptible(k));%Vedio写入
end
close(video_Position_of_Susceptible);
```

### 新的次级函数

#### 新的位置转移函数

```matlab
function state = NewPosition(map,state)
%% 更新易感者位置
for i = 1:state.number_of_susceptible
    stop = 0;
    %% 设置移动步长行列均为-1到1
    while stop == 0
    list = randperm(3,1);
    list = list-2;
    row = randperm(3,1);
    row = row-2;
    r = [list,row];
    P = r;


    if state.Position_of_susceptible(i,1)+P(1) >0 && state.Position_of_susceptible(i,2)+P(2) >0
    if abs(state.Position_of_susceptible(i,1)+P(1)) < size(map,1) && abs(state.Position_of_susceptible(i,2)+P(2)) < size(map,2) && abs(state.Position_of_susceptible(i,1)+r(1)) >0 && abs(state.Position_of_susceptible(i,2)+r(2)) >0%% 判断是否超越边界
     if map(abs(state.Position_of_susceptible(i,1)+P(1)),abs(state.Position_of_susceptible(i,2)+P(2))) == 0%判断是否会撞墙
        stop = 1;
     end
    end
    end
    end
        %% 更新位置
    state.Position_of_susceptible(i,1) = abs(state.Position_of_susceptible(i,1)+P(1));
    state.Position_of_susceptible(i,2) = abs(state.Position_of_susceptible(i,2)+P(2));
end
%% 更新携带者位置
for i = 1:state.number_of_exposed
        stop = 0;
    %% 设置移动步长行列均为-1到1
    while stop == 0
    list = randperm(3,1);
    list = list-2;
    row = randperm(3,1);
    row = row-2;
    r = [list,row];
   P = r;

    if state.Position_of_exposed(i,1)+r(1) >0 && state.Position_of_exposed(i,2)+r(2) >0
    if abs(state.Position_of_exposed(i,1)+r(1)) < size(map,1) && abs(state.Position_of_exposed(i,2)+r(2)) < size(map,2) && abs(state.Position_of_exposed(i,1)+r(1)) >0 && abs(state.Position_of_exposed(i,2)+r(2)) >0%% 判断是否超越边界
     if map(abs(state.Position_of_exposed(i,1)+r(1)),abs(state.Position_of_exposed(i,2)+r(2))) == 0%判断是否会撞墙
        stop = 1;
     end
    end
    end
    end
        %% 更新位置
    state.Position_of_exposed(i,1) = abs(state.Position_of_exposed(i,1)+P(1));
    state.Position_of_exposed(i,2) = abs(state.Position_of_exposed(i,2)+P(2));
end
%% 更新染病者位置
if state.number_of_infectious ~= 0
    for i = 1:state.number_of_infectious
        stop = 0;
    %% 设置移动步长行列均为-1到1
    while stop == 0
    list = randperm(3,1);
    list = list-2;
    row = randperm(3,1);
    row = row-2;
    r = [list,row];
    %% 判断是否越界
    
    if state.point == 1
         P_0 = state.point_Position;
         P1 = P_0 - state.Position_of_infectious(i,:);
         P = 0.2*rand*P1;
    P = round(P);
    else
    list = randperm(3,1);
    list = list-2;
    row = randperm(3,1);
    row = row-2;
    r = [list,row];
   P = r;
    end
    if abs(state.Position_of_infectious(i,1)+P(1)) >= size(map,1)
        P(1) = -1;
    end
    if abs(state.Position_of_infectious(i,2)+P(2)) >= size(map,2)
        P(2) = -1;
    end
    if abs(state.Position_of_infectious(i,1)+P(1)) <= 0
        P(1) = 1;
    end
    if abs(state.Position_of_infectious(i,2)+P(2)) <= 0
        P(2) = 1;
    end
    if state.Position_of_infectious(i,1)+P(1) >0 && state.Position_of_infectious(i,2)+P(2) >0
    if abs(state.Position_of_infectious(i,1)+P(1)) < size(map,1) && abs(state.Position_of_infectious(i,2)+P(2)) < size(map,2)%% 判断是否超越边界
        %if map((state.Position_of_infectious(i,1)+P(1)),abs(state.Position_of_infectious(i,2)+P(2))) == 0
        stop = 1;
        %end
    end
    end
    end
        %% 更新位置
    state.Position_of_infectious(i,1) = abs(state.Position_of_infectious(i,1)+P(1));
    state.Position_of_infectious(i,2) = abs(state.Position_of_infectious(i,2)+P(2));
    end
end
%% 更新无症状感染者位置
if state.number_of_asymptomatic ~= 0
    for i = 1:state.number_of_asymptomatic
        stop = 0;
    %% 设置移动步长行列均为-1到1
    while stop == 0
    list = randperm(3,1);
    list = list-2;
    row = randperm(3,1);
    row = row-2;
    r = [list,row];

    P = r;


    if state.Position_of_asymptomatic(i,1)+P(1) >0 && state.Position_of_asymptomatic(i,2)+P(2) >0
    if abs(state.Position_of_asymptomatic(i,1)+P(1)) < size(map,1) && abs(state.Position_of_asymptomatic(i,2)+P(2)) < size(map,2) %% 判断是否超越边界
     if map(abs(state.Position_of_asymptomatic(i,1)+P(1)),abs(state.Position_of_asymptomatic(i,2)+P(2))) == 0%判断是否会撞墙
        stop = 1;
     end
    end
    end
    end
        %% 更新位置
    state.Position_of_asymptomatic(i,1) = abs(state.Position_of_asymptomatic(i,1)+P(1));
    state.Position_of_asymptomatic(i,2) = abs(state.Position_of_asymptomatic(i,2)+P(2));
    end

end
if state.number_of_recovered ~= 0
     for i = 1:state.number_of_recovered
        stop = 0;
    %% 设置移动步长行列均为-1到1
    while stop == 0
    list = randperm(3,1);
    list = list-2;
    row = randperm(3,1);
    row = row-2;
    r = [list,row];
    P = r;
    if state.Position_of_recovered(i,1)+P(1) >0 && state.Position_of_recovered(i,2)+P(2) >0
    if abs(state.Position_of_recovered(i,1)+P(1)) < size(map,1) && abs(state.Position_of_recovered(i,2)+P(2)) < size(map,2) %% 判断是否超越边界
    %if map(abs(state.Position_of_recovered(i,1)+P(1)),abs(state.Position_of_recovered(i,2)+P(2))) == 0%判断是否会撞墙
        stop = 1;
    %end
    end
    end
    end
        %% 更新位置
    state.Position_of_recovered(i,1) = abs(state.Position_of_recovered(i,1)+P(1));
    state.Position_of_recovered(i,2) = abs(state.Position_of_recovered(i,2)+P(2));
     end
end
end
function w = weight(state)
w = 1 - 0.1*state.Iteration/state.Max_Iteration ;
end
```

### 新的状态更新函数

```matlab
function state = Updatestate(state,beta,alpha,p,delta,r_I,r_A,side)

%% 初始化
    judge_susceptible = zeros(state.number_of_susceptible,1);
    judge_exposed = zeros(state.number_of_exposed,1);
    judge_infectious = zeros(state.number_of_infectious,1);
    judge_asymptomatic = zeros(state.number_of_asymptomatic,1);
    %% 计算第i个易感者的邻域范围内有多少个感染者
for i =1:state.number_of_susceptible
    number_of_infectious = zeros(2*side);
    for j = -side:side
        for k = -side:side
            %% 防止超界(防止撞墙已经于NewPosition.m)中设计
            if state.Position_of_susceptible(i,1)+j <=0 || state.Position_of_susceptible(i,1)+j >=size(state.map,2)
                j_1 = 0;
            else
                j_1 = j;
            end
            if state.Position_of_susceptible(i,2)+k <=0 || state.Position_of_susceptible(i,2)+k >=size(state.map,1)
                k_1 = 0;
            else
                k_1 = k;
            end

            number_of_infectious(j+side+1,k+side+1) = sum(state.Position.infectious_Matrix(state.Position_of_susceptible(i,1)+j_1,state.Position_of_susceptible(i,2)+k_1))+ ...计算邻域范围内的感染者个数 
            sum(state.Position.asymptomatic_Matrix(state.Position_of_susceptible(i,1)+j_1,state.Position_of_susceptible(i,2)+k_1));%计算邻域范围内的无症状感染者个数
        end
    end
    %% 进行求和(分两步求和,方便报错检查)
number_of_infectious_1 = sum(number_of_infectious);
number_of_infectious_2 = sum(number_of_infectious_1);
    %% 判断是否被感染
    if rand <= f(number_of_infectious_2,beta)
        judge_susceptible(i) = 1;% 若judge_exposed(i) = 1则表示此时第i个易感者被感染,若为0则未被感染
    else 
        judge_susceptible(i) = 0;
    end
end
%% 携带者转化判定
for i=1:state.number_of_exposed
    if rand <= alpha%确诊
        if rand <= p
        judge_exposed(i) = 1;%转化为感染者
        else 
        judge_exposed(i) = 2;%转化为无症状感染者
        end
    else
        judge_exposed(i) = 0;%保持不变
    end
end
%% 感染者转化判定
if state.number_of_infectious >0
    for i = 1:state.number_of_infectious
        if rand <= r_I
            judge_infectious(i) = 1;%康复
        else
            judge_infectious(i) = 0;%保持不变
        end
    end
end
%% 无症状感染者转化判定
if state.number_of_asymptomatic >0
    for i = 1:state.number_of_asymptomatic
        if rand >= r_A
            if rand <= delta
                judge_asymptomatic(i) = 2;%转化为感染者
            else
                judge_asymptomatic(i) = 0;%保持不变
            end
        else 
            judge_asymptomatic(i) = 1;%转化为康复者
        end
    end
end
%% 总结
J_S_1 = find(judge_susceptible == 1);% S \to E
J_E_1 = find(judge_exposed == 1);% E \to I
J_E_2 = find(judge_exposed == 2);% E \to A
J_A_1 = find(judge_asymptomatic == 1);% A \to R
J_A_2 = find(judge_asymptomatic == 2);% A \to I
J_I_1 = find(judge_infectious == 1);% I \to R

%% Update阶段

%% 更新S
state.number_of_susceptible = state.number_of_susceptible - length(J_S_1);%更新易感者人数
S_to_E = zeros(length(J_S_1),2);
for i = 1: length(J_S_1)
    S_to_E(i,:) = state.Position_of_susceptible(J_S_1(i),:);
end
state.Position_of_susceptible(J_S_1,:) = [];%在易感者中删去携带者

%% 更新E
E_to_I = zeros(length(J_E_1),2);
E_to_A = zeros(length(J_E_2),2);
for i = 1:length(J_E_1)
    E_to_I(i,:) = state.Position_of_exposed(J_E_1(i),:);
end
for i = 1:length(J_E_2)
    E_to_A(i,:) = state.Position_of_exposed(J_E_2(i),:);
end
J_E = union(J_E_1,J_E_2);
state.number_of_exposed = state.number_of_exposed - length(J_E) + size(S_to_E,1);%更新携带者人数
state.Position_of_exposed(J_E,:) = [];%在携带者中删除流出部分
State_P_E = size(state.Position_of_exposed,1);
for i = size(state.Position_of_exposed,1)+1:state.number_of_exposed
    state.Position_of_exposed(i,:) = S_to_E(i - State_P_E,:);% 更新携带者位置
end


%% 更新A
if state.number_of_asymptomatic >0
A_to_R = zeros(length(J_A_1),2);
A_to_I = zeros(length(J_A_2),2);
for i = 1:length(J_A_1)
    A_to_R(i,:) = state.Position_of_asymptomatic(J_A_1(i),:);
end
for i = 1:length(J_A_2)
    A_to_I(i,:) = state.Position_of_asymptomatic(J_A_2(i),:);
end
J_A = union(J_A_1,J_A_2);
state.number_of_asymptomatic = state.number_of_asymptomatic - length(J_A) + size(E_to_A,1);%更新无症状感染者人数
state.Position_of_asymptomatic(J_A,:) = [];%在无症状感染者中删去流出部分
State_P_A = size(state.Position_of_asymptomatic,1);
for i = size(state.Position_of_asymptomatic,1)+1:state.number_of_asymptomatic
    state.Position_of_asymptomatic(i,:) = E_to_A(i- State_P_A,:);% 更新无症状感染者位置
end
else
    for i = 1:size(E_to_A,1)
    state.Position_of_asymptomatic(i,:) = E_to_A(i,:);% 更新无症状感染者位置
    end
    state.number_of_asymptomatic = length(J_E_2);
    A_to_I = [];
    A_to_R = [];
end


%% 更新I
if state.number_of_infectious >0
    I_to_R = zeros(length(J_I_1),2);
    for i = 1:length(J_I_1)
    I_to_R(i,:) = state.Position_of_infectious(J_I_1(i),:);
    end
  state.number_of_infectious = state.number_of_infectious - length(J_I_1) + size(A_to_I,1) + size(E_to_I,1);
  state.Position_of_infectious(J_I_1,:) = [];
  State_P_I = size(state.Position_of_infectious,1);
  for i = size(state.Position_of_infectious,1)+1:state.number_of_infectious - size(A_to_I,1)
    state.Position_of_infectious(i,:) = E_to_I(i-State_P_I,:);
  end
  State_P_I = size(state.Position_of_infectious,1);
  for i = size(state.Position_of_infectious,1)+1 : state.number_of_infectious
    state.Position_of_infectious(i,:) = A_to_I(i-State_P_I,:);
  end
else
    I_to_R = [];
    state.number_of_infectious = state.number_of_infectious +  size(A_to_I,1) + size(E_to_I,1);
    if state.number_of_infectious - size(A_to_I,1) >= 1
      for i = 1: state.number_of_infectious - size(A_to_I,1)
      state.Position_of_infectious(i,:) = E_to_I(i,:);
      end
    end

        State_P_I = size(state.Position_of_infectious,1);
     if state.number_of_infectious >1
  for i = size(state.Position_of_infectious,1)+1 : state.number_of_infectious
    state.Position_of_infectious(i,:) = A_to_I(i-State_P_I,:);
  end
     end
end

%% 更新R

for i = state.number_of_recovered+1 :state.number_of_recovered+ size(A_to_R,1) + size(I_to_R,1)
    if i- state.number_of_recovered <= size(A_to_R,1)
    state.Position_of_recovered(i,:) = A_to_R(i-state.number_of_recovered,:);
    else
    state.Position_of_recovered(i,:) = I_to_R(i-(state.number_of_recovered+ size(A_to_R,1)),:);
    end
end
state.number_of_recovered = state.number_of_recovered+ size(A_to_R,1) + size(I_to_R,1);

end

%% 设置感染率叠加函数
function a = f(number_of_infectious,beta)
if number_of_infectious*beta <= 0.9
    a = number_of_infectious;
else
    a = 0.9;
end
end
```

### 新的矩阵函数

```matlab
function state = TransMatrix(state)

%% 开始构建位置矩阵
map= zeros(size(state.map,1),size(state.map,2));%制造一个空地图
state.Position.susceptible_Matrix = map;
state.Position.exposed_Matrix = map;
state.Position.infectious_Matrix = map;
state.Position.asymptomatic_Matrix = map;
state.Position.recover_Matrix = map;
for i = 1:state.number_of_susceptible
    state.Position.susceptible_Matrix(state.Position_of_susceptible(i,1),state.Position_of_susceptible(i,2)) = 1;%将有人所在的位置赋值为1
end
for i = 1:state.number_of_exposed
    state.Position.exposed_Matrix(state.Position_of_exposed(i,1),state.Position_of_exposed(i,2)) = 1;
end
for i = 1:state.number_of_infectious
    state.Position.infectious_Matrix(state.Position_of_infectious(i,1),state.Position_of_infectious(i,2)) = 1;
end
for i = 1:state.number_of_asymptomatic
    state.Position.asymtomatic_Matrix(state.Position_of_asymptomatic(i,1),state.Position_of_asymptomatic(i,2)) = 1;
end
for i = 1:state.number_of_recovered
    state.Position.recover_Matrix(state.Position_of_recovered(i,1),state.Position_of_recovered(i,2)) = 1;
end
```

### 新的作图函数

```matlab
function Plotstate(state,Position_of_map)
        %% 易感者
        scatter(state.Position_of_susceptible(:,1),state.Position_of_susceptible(:,2),15,[126/256,211/256,33/256],"filled");
        hold on
        %% 携带者
        scatter(state.Position_of_exposed(:,1),state.Position_of_exposed(:,2),15,[248/256,231/256,28/256],"filled");
        hold on
        %% 感染者
        if state.number_of_infectious > 0
            scatter(state.Position_of_infectious(:,1),state.Position_of_infectious(:,2),15,[208/256,2/256,27/256],"filled");
            hold on
        end
        %% 无症状感染者
        if state.number_of_asymptomatic > 0
            scatter(state.Position_of_asymptomatic(:,1),state.Position_of_asymptomatic(:,2),15,[245/256,166/256,35/256],"filled");
            hold on
        end
        %% 康复以及疫苗
        if state.number_of_infectious > 0
            scatter(state.Position_of_recovered(:,1),state.Position_of_recovered(:,2),15,[74/256,144/256,226/256],"filled");
        %% 绘制边界
        scatter(Position_of_map(:,1),Position_of_map(:,2),3,[155/156,155/256,155/256],"square","filled");

end
```



